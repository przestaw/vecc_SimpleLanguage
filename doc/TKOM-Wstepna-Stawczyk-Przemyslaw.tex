% !TeX spellcheck = pl_PL
% !TEX encoding = UTF-8 Unicode

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage[T1]{fontenc} %font encoding ? --> need to clarify that
\usepackage[polish]{babel}

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
\geometry{margin=1in} % for example, change the margins to 2 inches all round

\usepackage{graphicx} % support the \includegraphics command and options
\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
%%% END Article customizations

%%% The "real" document content comes below...

\title{%
	Techniki Kompilacji - Projekt \\
	\large Interpreter prostego języka z typem wektorowym
	}
\author{Stawczyk Przemysław 293153}
\date{} % Activate to display a given date or no date (if empty),
% otherwise the current date is printed 


\begin{document}

\maketitle

%\begin{abstract}

%\end{abstract}

\section{Opis Projektu}
Projekt zakłada wykonanie interpretera prostego języka z obsługą wbudowanego typu \textsl{wektora} o \textsl{dim = \{1,2\}}. Język ten ma obsługiwać : zmienne z zasięgiem, instrukcje wykonywane na żądanie \textsl{funkcje}, instrukcje wykonywane nie zawsze \textsl{warunkowe}, wyrażenia matematyczne oraz operatory wraz z priorytetami.
\subsection{Ogólne założenia}
\begin{itemize}
	\item 
		Wartości liczbowe są reprezentowane przez liczby całkowite.
	\item
		Obsługiwane są typy : 
		\begin{itemize}
			\item 
				Typ liczbowy \textsl{skalar}.
			\item
				Typ wektorowy \textsl{vec} o \textsl{dim = \{1,2\}}\\ np. \textsl{vec(1,2), vec(4,5,6)}.
		\end{itemize}
	\item
		Na typach liczbowych można definiować wyrażenia arytmetyczne za pomocą operatorów: \textsl{+ - * / ( )} z uwzględnieniem ich priorytetu i łączności.
	\item
		Wykonywanie operacji na wektorach : iloczynu skalarnego oraz wektorowego. \textsl{z użyciem wbudowanych funkcji}
	\item
		Na typach \textsl{vec} i liczbowych można użyć operatorów przyrównania \textsl{== !=} oraz łączyć w wyrażenia za pomocą \textsl{|| \&\& ( )}.
	\item 
		Można definiować instrukcje warunkowe za pomocą konstrukcji \textsl{if()} oraz \textsl{else}.
	\item
		Można tworzyć pętle korzystając z konstrukcji \textsl{while()}.
	\item
		Można definiować funkcje z użycie słowa kluczowego \textsl{fun}.
	\item
		Zmienne są przekazywane do funkcji przez referencje.
	\item
		Program zaczyna wykonanie od bezparametrycznej funkcji \textsl{main()}
	\item 
		Wartości logiczne sa reprezentowane przez liczby gdzie 0=fałsz, !0 = prawda. Każdy wektor jest ewaluowany do prawdy.
	\item
		Język wspierać ma operację \textsl{print(...)} przyjmująca oprócz typów numerycznych stałe tekstowe \textsl{[w cudzysłowach " "]} istniejące wyłącznie na potrzeby \textsl{print}.
\end{itemize}
\subsection{Funkcje Biblioteczne}
\begin{itemize}
	\item fun \textbf{product3}(vec1, vec2) - \textit{iloczyn wektorowy wektorów wymiaru 3}
	\item fun \textbf{product2}(vec1, vec2) - \textit{iloczyn wektorowy wektorów wymiaru 2}
	\item fun \textbf{scalar3}(vec1, vec2) - \textit{iloczyn skalarny wektorów wymiaru 3}
	\item fun \textbf{scalar2}(vec1, vec2) - \textit{iloczyn skalarny wektorów wymiaru 2}
\end{itemize}

\section{Opis Struktury Języka}

TODO

\section{Założenia Implementacyjne}
Projekt miałby zostać zaimplementowany w języku \textit{C++} z użyciem biblioteki \textit{boost} do testów jednostkowych \textit{boost::unit\_test} oraz parsowania argumentów \textit{boost::program\_options}. Całość korzystać ma z narzędzia \textit{CMake} do zarządzania procesem budowania.
\paragraph{}
Program miałby składać się z następujących modułów : 
\begin{itemize}
	\item analizator leksykalny
	\item analizator składniowy
	\item interpreter
\end{itemize}
\subsection{Produkt Końcowy}
Finalny program ma być konsolowa aplikacja uruchamianą wraz z parametrem reprezentującym ścieżkę do pliku do interpretacji oraz poziomem wypisywanych informacji. Wynik poszczególnych etapów analizy pliku oraz samego wyniku interpretacji końcowej i wykonania będzie wyświetlany na standardowym wyjściu. W zależności od ogólnego wyniku analizy, na standardowe wyjście mogą być zgłaszane błędy: leksykalne, składniowe, semantyczne lub wynik wykonania skryptu.

\section{Przykłady}

\paragraph{Przykład 1}
\begin{verbatim}
fun licz(a) {
    a = a * 2;   
    if (a < 10) {      
        fun(a);   
    }    		 
    return a;  	
}  				
	
fun main() {
    if(11){
        print(fun(2));
    }
	  
}					
\end{verbatim}

\paragraph{Przykład 2}
\begin{verbatim}
fun printAndRet3(a) {
   print(a);
   return 3;
}

fun main() {
   var a = 0;
   if(a == 0) {
      print("a=";
      print(a);
   }

   print(vec(1,2));
   print(vec(1,2,3));

   var b = a;
   while(b < 10) {
      b = b + 1;
   }
   
   print("b= ", b);
   
   fun(1);
   fun(fun(2));
}   
\end{verbatim}


\end{document}
